
================================================================================
# ðŸ“„ run.py
================================================================================

# run.py

from apscheduler.schedulers.blocking import BlockingScheduler
from src.engine import main

def job():
    print("[SCHEDULER] Running scheduled MACD job...\n")
    main()

if __name__ == "__main__":
    scheduler = BlockingScheduler()
    scheduler.add_job(job, 'interval', minutes=1)
    print("[INIT] Starting scheduler to run MACD engine every minute...")
    scheduler.start()



================================================================================
# ðŸ“„ src/data_fetcher.py
================================================================================

import yfinance as yf
import pandas as pd

def get_historical_data(ticker, period='6mo', interval='1d'):
    try:
        df = yf.download(ticker, period=period, interval=interval, auto_adjust=False)
        if df is None or df.empty:
            print(f"[Warning] No data returned for {ticker}.")
            return pd.DataFrame()
        return df
    except Exception as e:
        print(f"[Error] Failed to fetch data for {ticker}: {e}")
        return pd.DataFrame()



================================================================================
# ðŸ“„ src/redis_client.py
================================================================================

# src/redis_client.py

import redis
from redis import Redis
from typing import Optional, cast, Union, List
import os
import json

REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
REDIS_PORT = int(os.getenv("REDIS_PORT", 6379))
REDIS_DB = int(os.getenv("REDIS_DB", 0))

r: Redis = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=REDIS_DB)

def save_macd_to_redis(ticker: str, interval: str, params: dict, data: Union[dict, List[dict]]) -> None:
    key = f"{ticker}:{interval}:{params['fast']}-{params['slow']}-{params['signal']}"
    try:
        r.set(key, json.dumps(data))
        print(f"[REDIS] Saved MACD for {key}")
    except Exception as e:
        print(f"[REDIS ERROR] Failed to save {key}: {e}")

def get_macd_from_redis(ticker: str, interval: str, params: dict) -> Optional[List[dict]]:
    key = f"{ticker}:{interval}:{params['fast']}-{params['slow']}-{params['signal']}"
    try:
        val = r.get(key)
        if val:
            val = cast(bytes, val)
            return json.loads(val.decode("utf-8"))
        return None
    except Exception as e:
        print(f"[REDIS ERROR] Failed to fetch {key}: {e}")
        return None


================================================================================
# ðŸ“„ src/config.py
================================================================================

# config.py

CRYPTO_TICKERS = [
    "BTC-USD", "ETH-USD", "BNB-USD", "SOL-USD", "XRP-USD", "DOGE-USD",
    "ADA-USD", "AVAX-USD", "SHIB-USD", "DOT-USD", "LINK-USD", "MATIC-USD",
    "TRX-USD", "LTC-USD", "BCH-USD", "ICP-USD", "ATOM-USD", "XLM-USD",
    "ETC-USD", "FIL-USD", "HBAR-USD", "APT-USD", "IMX-USD", "ARB-USD",
    "CRO-USD", "NEAR-USD", "QNT-USD", "OP-USD", "VET-USD", "RUNE-USD",
    "AAVE-USD", "GRT-USD", "EGLD-USD", "MKR-USD", "ALGO-USD", "XTZ-USD",
    "SAND-USD", "THETA-USD", "AXS-USD", "CHZ-USD", "ZEC-USD", "LDO-USD",
    "FTM-USD"
]

MACD_PARAMS = {
    '1m': [
        (12, 26, 9),
        (36, 78, 27),
        (60, 130, 45),
        (180, 390, 135),
        (360, 780, 270),
        (720, 1560, 540),
        (2160, 4680, 1620)
    ],
    '5m': [
        (12, 26, 9),
        (36, 78, 27),
        (72, 156, 54),
        (144, 312, 108),
        (432, 936, 324),
        (900, 1950, 675),
        (4500, 9750, 3375)
    ],
    '15m': [
        (12, 26, 9),
        (24, 52, 18),
        (48, 104, 36),
        (144, 312, 108),
        (300, 650, 225),
        (1500, 3250, 1125),
        (3000, 6500, 2250)
    ]
}



================================================================================
# ðŸ“„ src/engine.py
================================================================================

# src/engine.py

from src.data_fetcher import get_historical_data
from src.indicator_calculator import add_macd
from src.config import CRYPTO_TICKERS, MACD_PARAMS
from src.redis_client import save_macd_to_redis
import pandas as pd

def main():
    print("[INFO] Starting full scan of all tickers and MACD parameter sets...\n")

    for ticker in CRYPTO_TICKERS:
        for interval, param_list in MACD_PARAMS.items():
            # This print statement is optional but helpful for seeing progress
            # print(f"--- {ticker} @ {interval} ---")

            df = get_historical_data(ticker, period="7d", interval=interval)
            if df.empty:
                print(f"[WARNING] No data for {ticker} ({interval}) â€” skipping.")
                continue

            for params in param_list:
                fast, slow, signal = params

                df_macd = add_macd(df.copy(), fast=fast, slow=slow, signal=signal)
                if df_macd.empty:
                    continue

                last_three_rows = df_macd.tail(3)
                if len(last_three_rows) < 3:
                    continue

                # âœ… FINAL CORRECTED VERSION
                data_to_save = [
                    {
                        "macd_line": float(row.macd_line.iloc[0]),
                        "signal_line": float(row.signal_line.iloc[0]),
                        "histogram": float(row.histogram.iloc[0]),
                        "date": str(index.date())
                    }
                    for index, row in last_three_rows.iterrows()
                ]

                save_macd_to_redis(
                    ticker,
                    interval,
                    {"fast": fast, "slow": slow, "signal": signal},
                    data_to_save
                )

    print("\nâœ… [INFO] Full scan complete.\n")

if __name__ == "__main__":
    main()



================================================================================
# ðŸ“„ src/indicator_calculator.py
================================================================================

# indicator_calculator.py

import pandas as pd

def add_macd(df, fast=12, slow=26, signal=9):
    if 'Close' not in df.columns:
        print("[Error] 'Close' column not found in DataFrame.")
        return df

    # Calculate EMAs
    df['fast_ema'] = df['Close'].ewm(span=fast, adjust=False).mean()
    df['slow_ema'] = df['Close'].ewm(span=slow, adjust=False).mean()

    # MACD and Signal
    df['macd_line'] = df['fast_ema'] - df['slow_ema']
    df['signal_line'] = df['macd_line'].ewm(span=signal, adjust=False).mean()

    # Histogram
    df['histogram'] = df['macd_line'] - df['signal_line']

    return df



================================================================================
# ðŸ“„ api/app.py
================================================================================

import traceback
from flask import Flask, jsonify, request
from flask_cors import CORS
from src.redis_client import r
from api.logic_evaluator import evaluate_all_tickers, debug_single_rule  # âœ… Added debug_single_rule
from api.firestore_client import save_rule, get_all_rules                # âœ… Ensure get_all_rules is imported
import json
import os
from dotenv import load_dotenv
from typing import List, Optional

# Load API key from environment
load_dotenv()
API_KEY = os.getenv("API_KEY")

app = Flask(__name__)
CORS(app)

def require_api_key():
    client_key = request.headers.get('X-API-KEY')
    if not API_KEY or client_key != API_KEY:
        return jsonify({"error": "Unauthorized"}), 401
    return None

@app.route('/api/rules', methods=['POST'])
def create_rule():
    auth_error = require_api_key()
    if auth_error: return auth_error
    
    rule_data = request.get_json()
    if not rule_data or 'name' not in rule_data:
        return jsonify({"error": "Invalid rule data"}), 400
        
    saved_rule = save_rule(rule_data)
    return jsonify(saved_rule), 201

@app.route('/api/rules', methods=['GET'])
def list_rules():
    auth_error = require_api_key()
    if auth_error: return auth_error

    all_rules = get_all_rules()
    return jsonify(all_rules), 200

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({"status": "ok", "message": "API is running"})

@app.route('/api/data/<string:ticker>', methods=['GET'])
def get_data(ticker: str):
    auth_error = require_api_key()
    if auth_error:
        return auth_error

    try:
        keys = r.keys(f"{ticker}:*")
        keys: List[bytes] = keys
        
        if not keys:
            return jsonify({"error": f"No data found for ticker {ticker}"}), 404
        
        result = {ticker: {}}
        for key in keys:
            key_str = key.decode('utf-8')
            _, interval, params = key_str.split(':')
            data = r.get(key)
            data: Optional[bytes] = data
            if data:
                data_list = json.loads(data.decode('utf-8'))
                if isinstance(data_list, list) and len(data_list) == 3:
                    result[ticker][f"{interval}:{params}"] = [
                        {
                            "macd_line": item["macd_line"],
                            "signal_line": item["signal_line"],
                            "histogram": item["histogram"],
                            "date": item["date"]
                        }
                        for item in data_list
                    ]
        
        if not result[ticker]:
            return jsonify({"error": f"No valid data found for ticker {ticker}"}), 404
            
        return jsonify(result)
    
    except Exception as e:
        return jsonify({"error": f"Failed to fetch data for {ticker}: {str(e)}"}), 500

@app.route('/api/signals', methods=['GET'])
def get_signals():
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    try:
        signals = evaluate_all_tickers()
        return jsonify(signals), 200
    except Exception:
        error_trace = traceback.format_exc()
        print(error_trace)
        return jsonify({"error": "An internal error occurred", "traceback": error_trace}), 500

# âœ… NEW DEBUG ENDPOINT
@app.route('/api/debug/rule/<string:ticker>', methods=['GET'])
def debug_rule(ticker):
    auth_error = require_api_key()
    if auth_error:
        return auth_error

    all_rules = get_all_rules()
    if not all_rules:
        return jsonify({"error": "No rules found in the database to debug."}), 404

    first_rule = all_rules[0]
    debug_result = debug_single_rule(first_rule, ticker)
    return jsonify(debug_result)

if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=5000)



================================================================================
# ðŸ“„ api/logic_evaluator.py
================================================================================

# api/logic_evaluator.py
from src.redis_client import get_macd_from_redis
from src.config import CRYPTO_TICKERS
from api.firestore_client import get_all_rules

def get_operand_value(operand, ticker):
    """Recursively resolves the value of an operand."""
    if operand['type'] == 'literal':
        return operand['value']

    if operand['type'] == 'indicator':
        params_dict = {'fast': operand['params'][0], 'slow': operand['params'][1], 'signal': operand['params'][2]}
        redis_data = get_macd_from_redis(ticker, operand['timeframe'], params_dict)
        if not redis_data or len(redis_data) < 3:
            return None
        # offset: 0=CUR, -1=PAST1, -2=PAST2
        return redis_data[operand['offset'] - 1][operand['value']]

    if operand['type'] == 'expression':
        op = operand['operation']
        values = [get_operand_value(op_arg, ticker) for op_arg in operand['operands']]
        
        if any(v is None for v in values):
            return None
        
        try:
            if op == 'abs': return abs(values[0])
            if op == 'divide': return values[0] / values[1] if values[1] != 0 else None
        except Exception:
            return None
    return None

def evaluate_single_rule(rule, ticker):
    """Evaluates a full rule with all its conditions for a given ticker."""
    
    # âœ… THIS SAFETY CHECK PREVENTS CRASHES FROM BAD DATA
    if 'conditions' not in rule or not isinstance(rule['conditions'], list):
        return False

    for condition in rule['conditions']:
        val1 = get_operand_value(condition['operand1'], ticker)
        val2 = get_operand_value(condition['operand2'], ticker)

        if val1 is None or val2 is None:
            return False # Cannot evaluate if data is missing

        op = condition['operator']
        
        is_met = False
        if op == '>': is_met = val1 > val2
        elif op == '<': is_met = val1 < val2
        elif op == '>=': is_met = val1 >= val2
        elif op == '<=': is_met = val1 <= val2
        
        if not is_met:
            return False # If any condition fails, the whole rule fails
            
    return True # All conditions were met

def evaluate_all_tickers():
    """Loads all rules from Firestore and evaluates them against all tickers."""
    all_rules = get_all_rules()
    signals = {ticker: "NO_SIGNAL" for ticker in CRYPTO_TICKERS}

    if not all_rules:
        return signals

    for ticker in CRYPTO_TICKERS:
        for rule in all_rules:
            if evaluate_single_rule(rule, ticker):
                signals[ticker] = rule['signal']
                break # Move to the next ticker once a signal is found
    
    return signals

def debug_single_rule(rule, ticker):
    """Provides a detailed step-by-step evaluation of a rule for debugging."""
    if 'id' not in rule:
        return {"error": "Rule has no ID"}
        
    debug_log = {
        "rule_name": rule.get('name', 'N/A'),
        "ticker": ticker,
        "evaluation_trace": [],
        "final_result": "FAIL"
    }

    if 'conditions' not in rule or not isinstance(rule['conditions'], list):
        debug_log['error'] = "Rule has no 'conditions' or it is not a list."
        return debug_log

    all_conditions_met = True
    for i, condition in enumerate(rule['conditions']):
        trace_step = {}
        val1 = get_operand_value(condition.get('operand1'), ticker)
        val2 = get_operand_value(condition.get('operand2'), ticker)
        op = condition.get('operator')

        trace_step['step'] = i + 1
        trace_step['operand1_value'] = val1
        trace_step['operator'] = op
        trace_step['operand2_value'] = val2

        if val1 is None or val2 is None or op is None:
            trace_step['result'] = "FAIL (Missing Data)"
            all_conditions_met = False
        else:
            is_met = False
            if op == '>': is_met = val1 > val2
            elif op == '<': is_met = val1 < val2
            elif op == '>=': is_met = val1 >= val2
            elif op == '<=': is_met = val1 <= val2
            
            trace_step['result'] = "PASS" if is_met else "FAIL"
            if not is_met:
                all_conditions_met = False
        
        debug_log['evaluation_trace'].append(trace_step)

    if all_conditions_met:
        debug_log['final_result'] = "PASS"
        
    return debug_log



================================================================================
# ðŸ“„ api/firestore_client.py
================================================================================

# api/firestore_client.py
from google.cloud import firestore

# The library will now automatically use the VM's service account permissions
db = firestore.Client()
rules_collection = db.collection('rules')

def get_all_rules():
    """Fetches all documents from the 'rules' collection."""
    return [doc.to_dict() for doc in rules_collection.stream()]

def save_rule(rule_data: dict):
    """Saves a new rule to Firestore, letting Firestore auto-generate the ID."""
    doc_ref = rules_collection.document()
    rule_data['id'] = doc_ref.id
    doc_ref.set(rule_data)
    return rule_data




================================================================================
ðŸš€ FRONTEND CODE: ALL FILES IN frontend/src
================================================================================


================================================================================
# ðŸ“„ frontend/src/App.jsx
================================================================================

// frontend/src/App.jsx
import { Routes, Route, NavLink } from 'react-router-dom';
import Dashboard from './components/Dashboard';
import RuleBuilder from './components/RuleBuilder';

function App() {
  const linkStyle = "px-3 py-2 rounded-md text-sm font-medium";
  const activeLinkStyle = "bg-gray-900 text-white";
  const inactiveLinkStyle = "text-gray-300 hover:bg-gray-700 hover:text-white";

  return (
    <div>
      <nav className="bg-gray-800">
        <div className="container mx-auto px-4">
          <div className="flex items-center justify-start h-16">
            <NavLink to="/" className={({ isActive }) => `${linkStyle} ${isActive ? activeLinkStyle : inactiveLinkStyle}`}>
              Dashboard
            </NavLink>
            <NavLink to="/builder" className={({ isActive }) => `${linkStyle} ${isActive ? activeLinkStyle : inactiveLinkStyle}`}>
              Rule Builder
            </NavLink>
          </div>
        </div>
      </nav>
      <main className="bg-gray-100 min-h-screen">
        <Routes>
          <Route path="/" element={<Dashboard />} />
          <Route path="/builder" element={<RuleBuilder />} />
        </Routes>
      </main>
    </div>
  );
}

export default App;


================================================================================
# ðŸ“„ frontend/src/apiService.js
================================================================================

// frontend/src/apiService.js
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL;
const API_KEY = import.meta.env.VITE_API_KEY;

const apiClient = axios.create({
  baseURL: API_BASE_URL, // Should be http://34.83.108.47:5000
  headers: {
    'X-API-KEY': API_KEY,
    'Content-Type': 'application/json'
  }
});

// Use the full path from the base URL
export const getSignals = () => apiClient.get('/api/signals');
export const getRules = () => apiClient.get('/api/rules');
export const saveRule = (ruleData) => apiClient.post('/api/rules', ruleData);


================================================================================
# ðŸ“„ frontend/src/main.jsx
================================================================================

// frontend/src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';
import { BrowserRouter } from 'react-router-dom';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);


================================================================================
# ðŸ“„ frontend/src/index.css
================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;


================================================================================
# ðŸ“„ frontend/src/config.js
================================================================================

// frontend/src/config.js
export const TIME_FRAMES = ['1m', '5m', '15m'];
export const OPERATORS = ['>', '<', '>=', '<='];
export const MACD_VALUES = ['macd_line', 'signal_line', 'histogram'];

// A simplified list for the UI dropdowns
export const MACD_PARAMS_OPTIONS = [
    [12, 26, 9],
    [36, 78, 27],
    [24, 52, 18],
    [60, 130, 45]
];


================================================================================
# ðŸ“„ frontend/src/components/RuleBuilder.jsx
================================================================================

// frontend/src/components/RuleBuilder.jsx
import { useState, useEffect } from 'react';
import { getRules, saveRule } from '../apiService';
import { TIME_FRAMES, OPERATORS, MACD_VALUES, MACD_PARAMS_OPTIONS } from '../config';

// Reusable component for selecting an indicator
const OperandSelector = ({ value, onChange }) => (
  <div className="flex flex-col space-y-2 p-2 border rounded bg-gray-50">
    <select value={value.timeframe} onChange={e => onChange({ ...value, timeframe: e.target.value })} className="p-2 border rounded">
      {TIME_FRAMES.map(tf => <option key={tf} value={tf}>{tf}</option>)}
    </select>
    <select value={value.params.join(',')} onChange={e => onChange({ ...value, params: e.target.value.split(',').map(Number) })} className="p-2 border rounded">
      {MACD_PARAMS_OPTIONS.map(p => <option key={p.join(',')} value={p.join(',')}>{p.join(',')}</option>)}
    </select>
    <select value={value.value} onChange={e => onChange({ ...value, value: e.target.value })} className="p-2 border rounded">
      {MACD_VALUES.map(v => <option key={v} value={v}>{v}</option>)}
    </select>
  </div>
);

// The Main Rule Builder Component
function RuleBuilder() {
  const [rules, setRules] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  // Form state
  const [ruleName, setRuleName] = useState('');
  const [signal, setSignal] = useState('');
  const [op1, setOp1] = useState({ type: 'indicator', source: 'macd', timeframe: '1m', params: [12, 26, 9], value: 'macd_line', offset: 0 });
  const [operator, setOperator] = useState('>');
  const [op2, setOp2] = useState({ type: 'indicator', source: 'macd', timeframe: '1m', params: [12, 26, 9], value: 'signal_line', offset: 0 });

  const fetchRules = async () => {
    setIsLoading(true);
    try {
      const response = await getRules();
      setRules(response.data);
    } catch (error) {
      console.error("Failed to fetch rules:", error);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchRules();
  }, []);

  const handleSaveRule = async (e) => {
    e.preventDefault();

    // âœ… FINAL CORRECTED JSON STRUCTURE
    const ruleJSON = {
      name: ruleName,
      signal: signal,
      conditions: [{ 
        operand1: op1, 
        operator: operator, 
        operand2: op2 
      }]
    };

    try {
      await saveRule(ruleJSON);
      alert('Rule saved successfully!');
      setRuleName('');
      setSignal('');
      fetchRules(); // Refresh the list
    } catch (error) {
      console.error("Failed to save rule:", error);
      alert('Failed to save rule.');
    }
  };

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Logic Rule Builder</h1>
      <form onSubmit={handleSaveRule} className="bg-white shadow-md rounded-lg p-6 mb-8">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <input type="text" placeholder="Rule Name (e.g., My BTC Rule)" value={ruleName} onChange={e => setRuleName(e.target.value)} required className="p-2 border rounded" />
          <input type="text" placeholder="Signal on Trigger (e.g., BTC_CROSS_BUY)" value={signal} onChange={e => setSignal(e.target.value)} required className="p-2 border rounded" />
        </div>

        <h3 className="text-lg font-semibold mb-2">Condition:</h3>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-start">
          <OperandSelector value={op1} onChange={setOp1} />
          <select value={operator} onChange={e => setOperator(e.target.value)} className="p-2 border rounded self-center">
            {OPERATORS.map(op => <option key={op} value={op}>{op}</option>)}
          </select>
          <OperandSelector value={op2} onChange={setOp2} />
        </div>

        <button type="submit" className="mt-6 w-full bg-blue-500 text-white p-3 rounded font-semibold hover:bg-blue-600">
          Save New Rule
        </button>
      </form>

      <h2 className="text-xl font-bold mb-4">Saved Rules</h2>
      <div className="bg-white shadow-md rounded-lg p-4">
        {isLoading ? <p>Loading rules...</p> :
          <ul>
            {rules.map(rule => <li key={rule.id} className="border-b p-2">{rule.name} ({rule.signal})</li>)}
          </ul>
        }
      </div>
    </div>
  );
}

export default RuleBuilder;



================================================================================
# ðŸ“„ frontend/src/components/Dashboard.jsx
================================================================================

import { useState, useEffect } from 'react';
import { getSignals } from '../apiService';

function Dashboard() {
  const [signals, setSignals] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchSignals = async () => {
      try {
        const response = await getSignals();
        // Transform the response object into an array for easy mapping
        const signalsArray = Object.entries(response.data).map(([symbol, signal]) => ({
          symbol,
          signal,
        }));
        setSignals(signalsArray);
      } catch (error) {
        console.error('Error fetching signals:', error);
      } finally {
        // Set loading to false only after the first fetch
        if (loading) {
            setLoading(false);
        }
      }
    };

    fetchSignals(); // Initial fetch
    const interval = setInterval(fetchSignals, 15000); // Refresh every 15 seconds

    return () => clearInterval(interval); // Cleanup on component unmount
  }, [loading]); // Rerun effect if loading changes (for initial setup)

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-3xl font-bold text-center mb-6 text-gray-800">
        Real-Time Crypto Signals ðŸ“Š
      </h1>
      {loading ? (
        <p className="text-center text-gray-600">Loading signals...</p>
      ) : (
        <div className="overflow-x-auto">
          <table className="min-w-full bg-white shadow-md rounded-lg">
            <thead>
              <tr className="bg-gray-200 text-gray-600 uppercase text-sm leading-normal">
                <th className="py-3 px-6 text-left">Symbol</th>
                <th className="py-3 px-6 text-left">Signal</th>
              </tr>
            </thead>
            <tbody className="text-gray-600 text-sm font-light">
              {signals.map(({ symbol, signal }, index) => (
                <tr
                  key={symbol}
                  className={`border-b border-gray-200 hover:bg-gray-100 ${
                    index % 2 === 0 ? 'bg-gray-50' : ''
                  }`}
                >
                  <td className="py-3 px-6 text-left whitespace-nowrap font-medium">{symbol}</td>
                  <td className="py-3 px-6 text-left">
                    <span
                      className={`py-1 px-3 rounded-full text-xs font-semibold ${
                        signal.includes('BUY')
                          ? 'bg-green-200 text-green-800'
                          : signal.includes('SELL')
                          ? 'bg-red-200 text-red-800'
                          : 'bg-gray-200 text-gray-800'
                      }`}
                    >
                      {signal}
                    </span>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}

export default Dashboard;

