
================================================================================
# ðŸ“„ run.py
================================================================================

# run.py
import sys
import os
from dotenv import load_dotenv # <-- CHANGE #1: ADD THIS IMPORT

# Add the project root to the Python path and load environment variables
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
load_dotenv() # <-- CHANGE #2: ADD THIS LINE

from apscheduler.schedulers.blocking import BlockingScheduler
from src.engine import main

def job():
    print("[SCHEDULER] Running scheduled MACD job...\n")
    main()

if __name__ == "__main__":
    scheduler = BlockingScheduler()
    scheduler.add_job(job, 'interval', minutes=1)
    print("[INIT] Starting scheduler to run MACD engine every minute...")
    scheduler.start()



================================================================================
# ðŸ“„ api\app.py
================================================================================

# api/app.py

import sys
import os
import traceback
from flask import Flask, jsonify, request
from flask_cors import CORS
from src.redis_client import r
from api.logic_evaluator import get_signals_from_redis, debug_single_rule
from api.firestore_client import save_rule, get_all_rules, update_rule, delete_rule, get_rule_by_id # <-- CHANGE #1: ADD THIS IMPORT
import json
from dotenv import load_dotenv
from typing import List, Optional, cast
from src.config import MACD_PARAMS

# Ensure project root is on path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Load API key from environment
load_dotenv()
API_KEY = os.getenv("API_KEY")

app = Flask(__name__)
CORS(app)

def require_api_key():
    client_key = request.headers.get('X-API-KEY')
    if not API_KEY or client_key != API_KEY:
        return jsonify({"error": "Unauthorized"}), 401
    return None

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({"status": "ok", "message": "API is running"})

@app.route('/api/config', methods=['GET'])
def get_app_config():
    CANDLES_IN_7_DAYS = {
        '1m': 60 * 24 * 7,
        '5m': 12 * 24 * 7,
        '15m': 4 * 24 * 7
    }
    valid_params = {}
    for timeframe, params_list in MACD_PARAMS.items():
        max_candles = CANDLES_IN_7_DAYS.get(timeframe, 0)
        valid_params[timeframe] = [p for p in params_list if p[1] < max_candles]
    frontend_config = {
        'timeframes': list(MACD_PARAMS.keys()),
        'operators': ['>', '<', '>=', '<='],
        'macdValues': ['macd_line', 'signal_line', 'histogram'],
        'macdParamsByTimeframe': valid_params
    }
    return jsonify(frontend_config)

@app.route('/api/rules', methods=['POST'])
def create_rule():
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    rule_data = request.get_json()
    if not rule_data or 'name' not in rule_data:
        return jsonify({"error": "Invalid rule data"}), 400
    saved_rule = save_rule(rule_data)
    return jsonify(saved_rule), 201

@app.route('/api/rules', methods=['GET'])
def list_rules():
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    all_rules = get_all_rules()
    return jsonify(all_rules), 200

@app.route('/api/rules/<string:rule_id>', methods=['PUT'])
def update_rule_endpoint(rule_id):
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    rule_data = request.get_json()
    if not rule_data:
        return jsonify({"error": "Invalid data"}), 400
    updated_rule = update_rule(rule_id, rule_data)
    return jsonify(updated_rule), 200

@app.route('/api/rules/<string:rule_id>', methods=['DELETE'])
def delete_rule_endpoint(rule_id):
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    try:
        delete_rule(rule_id)
        return jsonify({"success": True}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/data/<string:ticker>', methods=['GET'])
def get_data(ticker: str):
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    try:
        # Cast to List[bytes] so Pylance knows it's iterable
        raw_keys = cast(List[bytes], r.keys(f"{ticker}:*"))
        if not raw_keys:
            return jsonify({"error": f"No data found for {ticker}"}), 404

        result = {ticker: {}}
        for key in raw_keys:
            key_str = key.decode('utf-8')
            _, interval, params = key_str.split(':')
            data_raw = cast(Optional[bytes], r.get(key))
            if not data_raw:
                continue

            data_list = json.loads(data_raw.decode('utf-8'))
            if isinstance(data_list, list) and len(data_list) == 3:
                result[ticker][f"{interval}:{params}"] = data_list

        if not result[ticker]:
            return jsonify({"error": f"No valid data found for {ticker}"}), 404

        return jsonify(result)
    except Exception as e:
        return jsonify({"error": f"Failed to fetch data for {ticker}: {str(e)}"}), 500

@app.route('/api/signals', methods=['GET'])
def get_signals():
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    try:
        signals_data = get_signals_from_redis()
        return jsonify(signals_data), 200
    except Exception:
        error_trace = traceback.format_exc()
        print(error_trace)
        return jsonify({"error": "An internal error occurred", "traceback": error_trace}), 500

# <-- CHANGE #2: THIS ROUTE HAS BEEN MODIFIED -->
@app.route('/api/debug/rule/<string:rule_id>/<string:ticker>', methods=['GET'])
def debug_rule(rule_id, ticker):
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    
    # Fetch the specific rule by its ID
    rule_to_debug = get_rule_by_id(rule_id)
    if not rule_to_debug:
        return jsonify({"error": f"Rule with ID '{rule_id}' not found."}), 404

    debug_result = debug_single_rule(rule_to_debug, ticker)
    return jsonify(debug_result)

if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=5000)


================================================================================
# ðŸ“„ api\firestore_client.py
================================================================================

# api/firestore_client.py

from google.cloud import firestore

# The library will now automatically use the VM's service account permissions
db = firestore.Client()
rules_collection = db.collection('rules')

# <-- CHANGE #1: ADD THIS NEW FUNCTION -->
def get_rule_by_id(rule_id: str):
    """Fetches a single rule document by its ID."""
    doc_ref = rules_collection.document(rule_id)
    doc = doc_ref.get()
    if doc.exists:
        return doc.to_dict()
    return None

def get_all_rules():
    """Fetches all documents from the 'rules' collection."""
    return [doc.to_dict() for doc in rules_collection.stream()]

def save_rule(rule_data: dict):
    """Saves a new rule to Firestore, letting Firestore auto-generate the ID."""
    doc_ref = rules_collection.document()
    rule_data['id'] = doc_ref.id
    doc_ref.set(rule_data)
    return rule_data

def update_rule(rule_id: str, rule_data: dict):
    """Updates an existing rule in Firestore."""
    doc_ref = rules_collection.document(rule_id)
    # Ensure the ID from the URL is used and saved in the document
    rule_data['id'] = rule_id
    doc_ref.set(rule_data) # set() with an existing doc ID overwrites it
    return rule_data

def delete_rule(rule_id: str):
    """Deletes a rule from Firestore."""
    rules_collection.document(rule_id).delete()


================================================================================
# ðŸ“„ api\logic_evaluator.py
================================================================================

# api/logic_evaluator.py

from src.redis_client import get_macd_from_redis, r
from src.config import CRYPTO_TICKERS
from api.firestore_client import get_all_rules
from api.notifications import send_telegram_message
import json
import datetime
import logging
from typing import cast, List, Dict, Optional # <-- CHANGE: Added 'cast', 'List', 'Dict', 'Optional'

# Configure logging
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

def save_signals_to_redis(signals):
    try:
        signals['last_updated'] = datetime.datetime.now().isoformat()
        r.set('latest_signals', json.dumps(signals))
        logging.info("Saved latest signals to Redis.")
    except Exception as e:
        logging.error(f"[REDIS ERROR] Failed to save latest signals: {e}")

def get_signals_from_redis():
    try:
        raw = r.get('latest_signals')
        if raw:
            # âœ… FIX: Explicitly cast the result to bytes before decoding.
            raw_bytes = cast(bytes, raw)
            return json.loads(raw_bytes.decode('utf-8'))
    except Exception as e:
        logging.error(f"[REDIS ERROR] Failed to get latest signals: {e}")
    return {
        'last_updated': datetime.datetime.now().isoformat(),
        'signals': {ticker: {"signal": "NO_SIGNAL", "rule_name": None} for ticker in CRYPTO_TICKERS}
    }

def get_operand_value(operand, ticker):
    """Recursively resolves the value of an operand."""
    if not operand:
        return None
    if operand['type'] == 'literal':
        return operand['value']

    if operand['type'] == 'indicator':
        params_dict = {'fast': operand['params'][0], 'slow': operand['params'][1], 'signal': operand['params'][2]}
        redis_data = get_macd_from_redis(ticker, operand['timeframe'], params_dict)
        if not redis_data or len(redis_data) < 3:
            return None
        return redis_data[operand['offset'] + 2][operand['value']]

    if operand['type'] == 'expression':
        op = operand['operation']
        values = [get_operand_value(op_arg, ticker) for op_arg in operand['operands']]

        if any(v is None for v in values):
            return None

        try:
            if op == 'abs':
                return abs(values[0])
            if op == 'divide':
                return values[0] / values[1] if values[1] != 0 else None
        except Exception:
            return None

    return None

def evaluate_single_rule(rule, ticker):
    """Evaluates a full rule with all its conditions for a given ticker."""
    if 'conditions' not in rule or not isinstance(rule['conditions'], list):
        return False

    for condition in rule['conditions']:
        val1 = get_operand_value(condition.get('operand1'), ticker)
        val2 = get_operand_value(condition.get('operand2'), ticker)

        if val1 is None or val2 is None:
            return False

        op = condition['operator']

        is_met = False
        if op == '>':
            is_met = val1 > val2
        elif op == '<':
            is_met = val1 < val2
        elif op == '>=':
            is_met = val1 >= val2
        elif op == '<=':
            is_met = val1 <= val2

        if not is_met:
            return False

    return True

# --- CHANGE #1: THIS NEW FUNCTION REPLACES evaluate_all_tickers() ---
def evaluate_single_ticker(ticker, send_notifications=False):
    """
    Loads all rules and evaluates them for a single ticker.
    If a signal is generated, it will send a Telegram alert.
    """
    all_rules = get_all_rules()
    
    # Get the existing signals and update only the current ticker
    current_signals = get_signals_from_redis()
    
    # Initialize a new signal for the current ticker
    signal_for_ticker = {"signal": "NO_SIGNAL", "rule_name": None}

    if not all_rules:
        # Update and save if no rules exist
        current_signals['signals'][ticker] = signal_for_ticker
        save_signals_to_redis(current_signals)
        return current_signals

    for rule in all_rules:
        if evaluate_single_rule(rule, ticker):
            current_signal = rule['signal']
            current_rule_name = rule.get('name', 'Unnamed Rule')

            signal_for_ticker['signal'] = current_signal
            signal_for_ticker['rule_name'] = current_rule_name

            # Check if this is a NEW signal before sending an alert
            previous_ticker_signal = current_signals.get('signals', {}).get(ticker, {}).get('signal', 'NO_SIGNAL')
            
            if send_notifications and rule.get('telegram_enabled', False) and current_signal != previous_ticker_signal:
                logging.info(f"âœ… SIGNAL DETECTED: Ticker={ticker}, Signal={current_signal}, Rule={current_rule_name}")
                logging.info("Triggering conditions:")
                for condition in rule['conditions']:
                    val1 = get_operand_value(condition.get('operand1'), ticker)
                    val2 = get_operand_value(condition.get('operand2'), ticker)
                    logging.info(f" -> {condition.get('operand1', {}).get('value')} {condition['operator']} {condition.get('operand2', {}).get('value')} -> {val1} {condition['operator']} {val2} is TRUE")

                rule_name_safe = current_rule_name.replace('-', '\\-').replace('.', '\\.')
                ticker_safe = ticker.replace('-', '\\-')
                signal_safe = current_signal.replace('-', '\\-').replace('(', '\\(').replace(')', '\\)')

                message = (
                    f"ðŸš¨ *NNTE Signal Alert* ðŸš¨\n\n"
                    f"*Ticker:* `{ticker_safe}`\n"
                    f"*Signal:* `{signal_safe}`\n"
                    f"*Rule:* `{rule_name_safe}`"
                )
                send_telegram_message(message)
            
            break
    
    current_signals['signals'][ticker] = signal_for_ticker
    save_signals_to_redis(current_signals)
    return current_signals

def debug_single_rule(rule, ticker):
    if 'id' not in rule:
        return {"error": "Rule has no ID"}

    debug_log = {
        "rule_name": rule.get('name', 'N/A'),
        "ticker": ticker,
        "evaluation_trace": [],
        "final_result": "FAIL"
    }

    if 'conditions' not in rule or not isinstance(rule['conditions'], list):
        debug_log['error'] = "Rule has no 'conditions' or it is not a list."
        return debug_log

    all_conditions_met = True
    for i, condition in enumerate(rule['conditions']):
        trace_step = {}
        val1 = get_operand_value(condition.get('operand1'), ticker)
        val2 = get_operand_value(condition.get('operand2'), ticker)
        op = condition.get('operator')

        trace_step['step'] = i + 1
        trace_step['operand1_value'] = val1
        trace_step['operator'] = op
        trace_step['operand2_value'] = val2

        if val1 is None or val2 is None or op is None:
            trace_step['result'] = "FAIL (Missing Data)"
            all_conditions_met = False
        else:
            is_met = False
            if op == '>':
                is_met = val1 > val2
            elif op == '<':
                is_met = val1 < val2
            elif op == '>=':
                is_met = val1 >= val2
            elif op == '<=':
                is_met = val1 <= val2

            trace_step['result'] = "PASS" if is_met else "FAIL"
            if not is_met:
                all_conditions_met = False

        debug_log['evaluation_trace'].append(trace_step)

    if all_conditions_met:
        debug_log['final_result'] = "PASS"

    return debug_log


================================================================================
# ðŸ“„ api\notifications.py
================================================================================

# ðŸ“„ api/notifications.py

import requests
import os

def send_telegram_message(message: str):
    """Sends a message to the Telegram channel configured in the .env file."""
    
    token = os.getenv("TELEGRAM_BOT_TOKEN")
    chat_id = os.getenv("TELEGRAM_CHAT_ID")
    
    if not token or not chat_id:
        print("[TELEGRAM ERROR] Bot Token or Chat ID is not configured in .env file.")
        return

    # Using MarkdownV2 for better formatting
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": message,
        "parse_mode": "MarkdownV2" 
    }
    
    try:
        response = requests.post(url, json=payload)
        response.raise_for_status() # Will raise an exception for 4xx/5xx errors
        print(f"[TELEGRAM] Sent message: {message.splitlines()[0]}...")
    except requests.exceptions.RequestException as e:
        print(f"[TELEGRAM ERROR] Failed to send message: {e}")



================================================================================
# ðŸ“„ src\config.py
================================================================================

# config.py

CRYPTO_TICKERS = [
    "BTC-USD", "ETH-USD", "BNB-USD", "SOL-USD", "XRP-USD", "DOGE-USD",
    "ADA-USD", "AVAX-USD", "SHIB-USD", "DOT-USD", "LINK-USD", "MATIC-USD",
    "TRX-USD", "LTC-USD", "BCH-USD", "ICP-USD", "ATOM-USD", "XLM-USD",
    "ETC-USD", "FIL-USD", "HBAR-USD", "APT-USD", "IMX-USD", "ARB-USD",
    "CRO-USD", "NEAR-USD", "QNT-USD", "OP-USD", "VET-USD", "RUNE-USD",
    "AAVE-USD", "GRT-USD", "EGLD-USD", "MKR-USD", "ALGO-USD", "XTZ-USD",
    "SAND-USD", "THETA-USD", "AXS-USD", "CHZ-USD", "ZEC-USD", "LDO-USD",
    "FTM-USD"
]

MACD_PARAMS = {
    '1m': [
        (12, 26, 9),
        (36, 78, 27),
        (60, 130, 45),
        (180, 390, 135),
        (360, 780, 270),
        (720, 1560, 540),
        (2160, 4680, 1620)
    ],
    '5m': [
        (12, 26, 9),
        (36, 78, 27),
        (72, 156, 54),
        (144, 312, 108),
        (432, 936, 324),
        (900, 1950, 675),
        (4500, 9750, 3375)
    ],
    '15m': [
        (12, 26, 9),
        (24, 52, 18),
        (48, 104, 36),
        (144, 312, 108),
        (300, 650, 225),
        (1500, 3250, 1125),
        (3000, 6500, 2250)
    ]
}



================================================================================
# ðŸ“„ src\data_fetcher.py
================================================================================

import yfinance as yf
import pandas as pd

def get_historical_data(ticker, period='6mo', interval='1d'):
    try:
        df = yf.download(ticker, period=period, interval=interval, auto_adjust=False)
        if df is None or df.empty:
            print(f"[Warning] No data returned for {ticker}.")
            return pd.DataFrame()
        return df
    except Exception as e:
        print(f"[Error] Failed to fetch data for {ticker}: {e}")
        return pd.DataFrame()



================================================================================
# ðŸ“„ src\indicator_calculator.py
================================================================================

import pandas as pd
from src.redis_client import get_macd_from_redis, save_macd_to_redis
import logging
from typing import List, Dict, cast, Tuple

# This function is now used to calculate the new MACD values incrementally
def update_macd_incremental(ticker: str, interval: str, params: Tuple[int, int, int], new_close: float) -> List[Dict]:
    fast, slow, signal = params
    
    key_params = {"fast": fast, "slow": slow, "signal": signal}
    
    existing_data = get_macd_from_redis(ticker, interval, key_params)
    
    if existing_data:
        from src.data_fetcher import get_historical_data
        df = get_historical_data(ticker, period="10m", interval=interval)
        if df.empty or len(df) <= slow:
            logging.warning(f"[INSUFFICIENT DATA] Skipping incremental MACD for {ticker} ({interval}).")
            return []
            
        df['close'] = df['Close']
        df['fast_ema'] = df['close'].ewm(span=fast, adjust=False).mean()
        df['slow_ema'] = df['close'].ewm(span=slow, adjust=False).mean()
        df['macd_line'] = df['fast_ema'] - df['slow_ema']
        df['signal_line'] = df['macd_line'].ewm(span=signal, adjust=False).mean()
        df['histogram'] = df['macd_line'] - df['signal_line']
        
        last_three = df.tail(3)
        if len(last_three) < 3:
            return []
        
        data_to_save = []
        # Explicitly cast idx to pd.Timestamp
        for idx, row in last_three.iterrows():
            ts = cast(pd.Timestamp, idx)
            date_str = str(ts.date())
            data_to_save.append({
                "macd_line": float(row.macd_line.item()),
                "signal_line": float(row.signal_line.item()),
                "histogram": float(row.histogram.item()),
                "date": date_str
            })
            
        save_macd_to_redis(ticker, interval, key_params, data_to_save)
        return data_to_save
        
    else:
        from src.data_fetcher import get_historical_data
        df = get_historical_data(ticker, period="7d", interval=interval)
        if df.empty or len(df) <= slow:
            logging.warning(f"[INSUFFICIENT DATA] Skipping initial MACD calculation for {ticker} ({interval}).")
            return []
            
        df_macd = add_macd(df.copy(), fast=fast, slow=slow, signal=signal)
        
        last_three = df_macd.tail(3)
        if len(last_three) < 3:
            return []

        data_to_save = []
        # Explicitly cast idx to pd.Timestamp
        for idx, row in last_three.iterrows():
            ts = cast(pd.Timestamp, idx)
            date_str = str(ts.date())
            data_to_save.append({
                "macd_line": float(row.macd_line.item()),
                "signal_line": float(row.signal_line.item()),
                "histogram": float(row.histogram.item()),
                "date": date_str
            })
            
        save_macd_to_redis(ticker, interval, key_params, data_to_save)
        return data_to_save

# The original add_macd function is still useful for initial historical calculations.
def add_macd(df, fast=12, slow=26, signal=9):
    if len(df) <= slow:
        logging.warning(f"[INSUFFICIENT DATA] SKIPPING MACD({fast},{slow},{signal}). Have {len(df)} candles, need > {slow}.")
        return pd.DataFrame()

    if 'Close' not in df.columns:
        logging.error("[Error] 'Close' column not found in DataFrame.")
        return df

    df['fast_ema'] = df['Close'].ewm(span=fast, adjust=False).mean()
    df['slow_ema'] = df['Close'].ewm(span=slow, adjust=False).mean()
    df['macd_line'] = df['fast_ema'] - df['slow_ema']
    df['signal_line'] = df['macd_line'].ewm(span=signal, adjust=False).mean()
    df['histogram'] = df['macd_line'] - df['signal_line']
    return df



================================================================================
# ðŸ“„ src\realtime_engine.py
================================================================================

# src/realtime_engine.py

from binance import ThreadedWebsocketManager
import pandas as pd
from typing import Dict
from src.config import CRYPTO_TICKERS, MACD_PARAMS
from src.redis_client import r
from src.indicator_calculator import update_macd_incremental
from api.logic_evaluator import evaluate_single_ticker
import json
import logging

class RealtimeEngine:
    def __init__(self):
        self.twm = ThreadedWebsocketManager()
        self.twm.start()
        self.streams = self._get_all_streams()

    def _get_all_streams(self):
        streams = []
        for ticker in CRYPTO_TICKERS:
            # Normalize ticker for Binance streams (e.g., BTC-USD -> btcusdt)
            symbol = ticker.lower().replace('-', '')
            for interval in MACD_PARAMS.keys():
                streams.append(f'{symbol}@kline_{interval}')
        return streams

    def _handle_socket_message(self, msg):
        """
        Processes a new kline message from the WebSocket.
        This function will be the core of our real-time processing.
        """
        try:
            kline = msg['k']
            is_candle_closed = kline['x']
            if not is_candle_closed:
                # We only want to process closed candles to avoid false signals
                return

            symbol = kline['s'] # e.g., 'BTCUSDT'
            interval = kline['i'] # e.g., '1m'
            close_price = float(kline['c'])

            ticker = symbol.upper().replace('USDT', '-USD') # e.g., 'BTC-USD'
            
            # Retrieve the relevant MACD parameters for this interval
            macd_params_list = MACD_PARAMS.get(interval, [])

            for fast, slow, signal in macd_params_list:
                # Update MACD values for a single parameter set
                new_macd_data = update_macd_incremental(
                    ticker,
                    interval,
                    (fast, slow, signal),
                    close_price
                )
                
            # After all MACD indicators are updated for this ticker, evaluate the rules
            evaluate_single_ticker(ticker, send_notifications=True)
            
            logging.info(f"Processed closed candle for {ticker} on interval {interval}. Rules evaluated.")

        except KeyError:
            # Sometimes the first message can be malformed
            return
        except Exception as e:
            logging.error(f"[WEBSOCKET ERROR] Failed to process message: {e}")

    def start(self):
        """
        Starts the WebSocket streams and enters a blocking state.
        This replaces the role of the scheduler in the old setup.
        """
        # Subscribe to all streams and register a single handler
        self.twm.start_multiplex_socket(callback=self._handle_socket_message, streams=self.streams)
        
        # This blocks forever, but the twm runs in separate threads
        self.twm.join()


================================================================================
# ðŸ“„ src\redis_client.py
================================================================================

# src/redis_client.py

import redis
from redis import Redis
from typing import Optional, cast, Union, List
import os
import json

REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
REDIS_PORT = int(os.getenv("REDIS_PORT", 6379))
REDIS_DB = int(os.getenv("REDIS_DB", 0))

r: Redis = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=REDIS_DB)

def save_macd_to_redis(ticker: str, interval: str, params: dict, data: Union[dict, List[dict]]) -> None:
    key = f"{ticker}:{interval}:{params['fast']}-{params['slow']}-{params['signal']}"
    try:
        r.set(key, json.dumps(data))
        print(f"[REDIS] Saved MACD for {key}")
    except Exception as e:
        print(f"[REDIS ERROR] Failed to save {key}: {e}")

def get_macd_from_redis(ticker: str, interval: str, params: dict) -> Optional[List[dict]]:
    key = f"{ticker}:{interval}:{params['fast']}-{params['slow']}-{params['signal']}"
    try:
        val = r.get(key)
        if val:
            val = cast(bytes, val)
            return json.loads(val.decode("utf-8"))
        return None
    except Exception as e:
        print(f"[REDIS ERROR] Failed to fetch {key}: {e}")
        return None



================================================================================
ðŸš€ FRONTEND CODE: ALL FILES IN frontend/src
================================================================================


================================================================================
# ðŸ“„ frontend\src\apiService.js
================================================================================

// frontend/src/apiService.js
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL;
const API_KEY = import.meta.env.VITE_API_KEY;

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'X-API-KEY': API_KEY,
    'Content-Type': 'application/json'
  }
});

// âœ… NEW FUNCTION
export const getConfig = () => apiClient.get('/api/config');

export const getSignals = () => apiClient.get('/api/signals');
export const getRules = () => apiClient.get('/api/rules');
export const saveRule = (ruleData) => apiClient.post('/api/rules', ruleData);
export const updateRule = (ruleId, ruleData) => apiClient.put(`/api/rules/${ruleId}`, ruleData);
export const deleteRule = (ruleId) => apiClient.delete(`/api/rules/${ruleId}`);


================================================================================
# ðŸ“„ frontend\src\App.jsx
================================================================================

// frontend/src/App.jsx

import { Routes, Route, NavLink } from 'react-router-dom';
import Dashboard from './components/Dashboard';
import RuleBuilder from './components/RuleBuilder';

function App() {
  const linkStyle = "px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200";
  const activeLinkStyle = "bg-blue-600 text-white shadow-md";
  const inactiveLinkStyle = "text-gray-300 hover:bg-gray-700 hover:text-white";

  return (
    <div className="min-h-screen bg-[var(--bg-dark-primary)] text-[var(--text-primary)]">
      <nav className="bg-[var(--bg-dark-secondary)] border-b border-[var(--border-color)] shadow-lg">
        <div className="container mx-auto px-4">
          <div className="flex items-center justify-between h-16">

            {/* NNTE Branding Section */}
            <div className="flex items-center space-x-3">
              <div className="bg-blue-600 p-2 rounded-lg">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" /></svg>
              </div>
              <div className="flex flex-col">
                <span className="font-extrabold text-xl text-white tracking-wider">NNTE</span>
                {/* IMPROVEMENT: Hide descriptive text on smaller screens */}
                <span className="text-xs text-[var(--text-secondary)] hidden">Neural Network Traders Empire</span>
              </div>
            </div>

            {/* Navigation Links */}
            <div className="flex items-center space-x-4">
              <NavLink to="/" className={({ isActive }) => `${linkStyle} ${isActive ? activeLinkStyle : inactiveLinkStyle}`}>
                Dashboard
              </NavLink>
              <NavLink to="/builder" className={({ isActive }) => `${linkStyle} ${isActive ? activeLinkStyle : inactiveLinkStyle}`}>
                Rule Builder
              </NavLink>
            </div>
          </div>
        </div>
      </nav>

      <main>
        <Routes>
          <Route path="/" element={<Dashboard />} />
          <Route path="/builder" element={<RuleBuilder />} />
        </Routes>
      </main>
    </div>
  );
}

export default App;


================================================================================
# ðŸ“„ frontend\src\config.js
================================================================================

// frontend/src/config.js
export const TIME_FRAMES = ['1m', '5m', '15m'];
export const OPERATORS = ['>', '<', '>=', '<='];
export const MACD_VALUES = ['macd_line', 'signal_line', 'histogram'];

// âœ… CORRECTED STRUCTURE: Parameters are now grouped by timeframe
export const MACD_PARAMS_BY_TIMEFRAME = {
  '1m': [
    [12, 26, 9], [36, 78, 27], [60, 130, 45], [180, 390, 135],
    [360, 780, 270], [720, 1560, 540], [2160, 4680, 1620]
  ],
  '5m': [
    [12, 26, 9], [36, 78, 27], [72, 156, 54], [144, 312, 108],
    [432, 936, 324], [900, 1950, 675], [4500, 9750, 3375]
  ],
  '15m': [
    [12, 26, 9], [24, 52, 18], [48, 104, 36], [144, 312, 108],
    [300, 650, 225], [1500, 3250, 1125], [3000, 6500, 2250]
  ]
};


================================================================================
# ðŸ“„ frontend\src\index.css
================================================================================

/* frontend/src/index.css */

/* Import a clean, modern font from Google Fonts */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

/* Define our new NNTE color palette */
:root {
  --bg-dark-primary: #121212;      /* Deepest background */
  --bg-dark-secondary: #1E1E1E;    /* Card/container backgrounds */
  --border-color: #333333;        /* Borders and dividers */

  --text-primary: #EAEAEA;         /* Primary text */
  --text-secondary: #A0A0A0;      /* Softer, secondary text */

  --accent-buy: #22c55e;           /* Green for BUY signals */
  --accent-buy-bg: rgba(34, 197, 94, 0.1);
  --accent-sell: #ef4444;          /* Red for SELL signals */
  --accent-sell-bg: rgba(239, 68, 68, 0.1);

  --accent-primary: #3b82f6;      /* Blue for primary buttons/actions */
  --accent-primary-hover: #2563eb;
}

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Apply base styles to the body */
html {
  font-size: 16px; /* Base font size for rem units */
}

body {
  background-color: var(--bg-dark-primary);
  color: var(--text-primary);
  font-family: 'Inter', sans-serif;
  min-width: 320px; /* Prevent layout issues on very small screens */
}

/* Custom styling for the Telegram toggle switch we created */
.dot {
    transition: transform 0.2s ease-in-out, background-color 0.2s ease-in-out;
}
input:checked ~ .dot {
    transform: translateX(100%);
    background-color: var(--accent-buy);
}
input:checked + .block {
    background-color: var(--accent-buy-bg);
    border: 1px solid var(--accent-buy);
}
.block {
    border: 1px solid var(--border-color);
}


================================================================================
# ðŸ“„ frontend\src\main.jsx
================================================================================

// frontend/src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';
import { BrowserRouter } from 'react-router-dom';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);


================================================================================
# ðŸ“„ frontend\src\components\Dashboard.jsx
================================================================================

// frontend/src/components/Dashboard.jsx

import { useState, useEffect } from 'react';
import { getSignals, getRules } from '../apiService';

// A small SVG component for the refresh spinner
const RefreshSpinner = () => (
    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
);

function Dashboard() {
    const [signals, setSignals] = useState([]);
    const [rules, setRules] = useState([]);
    const [initialLoading, setInitialLoading] = useState(true);
    const [isRefreshing, setIsRefreshing] = useState(false);

    const [activeRuleFilter, setActiveRuleFilter] = useState('all');
    const [showNoSignal, setShowNoSignal] = useState(false);
    const [lastUpdated, setLastUpdated] = useState(new Date());

    useEffect(() => {
        const fetchAllData = async () => {
            if (!initialLoading) {
                setIsRefreshing(true);
            }

            try {
                const [signalsResponse, rulesResponse] = await Promise.all([getSignals(), getRules()]);
                const signalData = signalsResponse.data.signals || {};
                const lastUpdatedTimestamp = signalsResponse.data.last_updated;

                const signalsArray = Object.entries(signalData).map(([symbol, data]) => ({
                    symbol,
                    signal: data.signal,
                    rule_name: data.rule_name,
                }));
                setSignals(signalsArray);
                setRules(rulesResponse.data);
                if (lastUpdatedTimestamp) {
                    setLastUpdated(new Date(lastUpdatedTimestamp));
                }
            } catch (error) {
                console.error('Error fetching dashboard data:', error);
            } finally {
                if (initialLoading) setInitialLoading(false);
                setIsRefreshing(false);
            }
        };

        fetchAllData();
        const interval = setInterval(fetchAllData, 15000);
        return () => clearInterval(interval);
    }, [initialLoading]);

    const filteredSignals = signals.filter(s => {
        const ruleMatch = activeRuleFilter === 'all' || s.rule_name === activeRuleFilter;
        const signalMatch = showNoSignal || s.signal !== 'NO_SIGNAL';
        return ruleMatch && signalMatch;
    });

    if (initialLoading) {
        return <p className="text-center text-[var(--text-secondary)] mt-20 text-lg">Initializing Signal Matrix...</p>;
    }

    return (
        <div className="container mx-auto p-4 md:p-6">
            <div className="text-center mb-6">
                <h1 className="text-3xl md:text-4xl font-extrabold text-white">Signal Dashboard</h1>
                <div className="flex items-center justify-center mt-2 text-[var(--text-secondary)]">
                    {isRefreshing && <RefreshSpinner />}
                    <span>Last updated: {lastUpdated.toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}</span> {/* âœ… FIX: Use toLocaleString for IST */}
                </div>
            </div>

            <div className="bg-[var(--bg-dark-secondary)] border border-[var(--border-color)] p-4 rounded-xl shadow-lg mb-8">
                <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
                    <div className="flex items-center flex-wrap gap-2 justify-center sm:justify-start">
                        <span className="font-semibold text-gray-300 mr-2">Filter by Logic:</span>
                        <button
                            onClick={() => setActiveRuleFilter('all')}
                            className={`px-3 py-1 text-sm font-medium rounded-full transition-colors ${activeRuleFilter === 'all' ? 'bg-blue-600 text-white' : 'bg-[var(--bg-dark-primary)] hover:bg-gray-700'}`}>
                            All Signals
                        </button>
                        {rules.map(rule => (
                            <button
                                key={rule.id}
                                onClick={() => setActiveRuleFilter(rule.name)}
                                className={`px-3 py-1 text-sm font-medium rounded-full transition-colors ${activeRuleFilter === rule.name ? 'bg-blue-600 text-white' : 'bg-[var(--bg-dark-primary)] hover:bg-gray-700'}`}>
                                {rule.name}
                            </button>
                        ))}
                    </div>

                    <label htmlFor="showNoSignal" className="flex items-center cursor-pointer mt-4 sm:mt-0">
                        <span className="mr-3 text-sm text-[var(--text-secondary)]">Show 'NO_SIGNAL'</span>
                        <div className="relative">
                            <input type="checkbox" id="showNoSignal" className="sr-only" checked={showNoSignal} onChange={e => setShowNoSignal(e.target.checked)} />
                            <div className="block bg-gray-600 w-10 h-6 rounded-full"></div>
                            <div className="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full"></div>
                        </div>
                    </label>
                </div>
            </div>

            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-5">
                {filteredSignals.map(({ symbol, signal, rule_name }) => {
                    const isBuy = signal.includes('BUY');
                    const isSell = signal.includes('SELL');
                    const signalColorClass = isBuy ? 'text-[var(--accent-buy)]' : isSell ? 'text-[var(--accent-sell)]' : 'text-[var(--text-secondary)]';
                    const signalBgClass = isBuy ? 'bg-[var(--accent-buy-bg)]' : isSell ? 'bg-[var(--accent-sell-bg)]' : 'bg-gray-700/20';
                    const borderColorClass = isBuy ? 'border-[var(--accent-buy)]' : isSell ? 'border-[var(--accent-sell)]' : 'border-[var(--border-color)]';

                    return (
                        <div key={symbol} className={`bg-[var(--bg-dark-secondary)] rounded-lg shadow-xl border-l-4 ${borderColorClass} p-5 flex flex-col justify-between transition-transform transform hover:scale-105`}>
                            <div>
                                <div className="font-bold text-2xl text-white mb-2">{symbol}</div>
                                <div className={`font-semibold text-lg ${signalColorClass} mb-3`}>{signal}</div>
                            </div>
                            <div className={`text-xs text-right text-[var(--text-secondary)] italic p-2 rounded-md ${signalBgClass}`}>
                                {rule_name || 'N/A'}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
}

export default Dashboard;


================================================================================
# ðŸ“„ frontend\src\components\RuleBuilder.jsx
================================================================================

// frontend/src/components/RuleBuilder.jsx

import { useState, useEffect, useCallback } from 'react';
import { getRules, saveRule, updateRule, deleteRule, getConfig } from '../apiService';

// --- Helper Icons ---
const CloseIcon = () => (
    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
);
const Spinner = () => (
    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
);

// --- Reusable Components ---
const defaultLiteral = { type: 'literal', value: 0 };

const AdvancedOperandSelector = ({ value, onChange, config }) => {
    if (!value || !config) {
        // IMPROVEMENT: More prominent loading state for operands
        return <div className="p-4 border border-[var(--border-color)] rounded-lg bg-[var(--bg-dark-primary)] animate-pulse h-52 flex items-center justify-center text-[var(--text-secondary)]">
            Loading operand options...
        </div>;
    }
    const isIndicator = value.type === 'indicator';
    const handleTypeChange = (e) => {
        const newType = e.target.value;
        if (newType === 'indicator') {
            const defaultTimeframe = config.timeframes[0];
            const defaultParams = config.macdParamsByTimeframe[defaultTimeframe][0];
            onChange({ type: 'indicator', source: 'macd', timeframe: defaultTimeframe, params: defaultParams, value: 'macd_line', offset: 0 });
        } else {
            onChange(defaultLiteral);
        }
    };
    const handleTimeframeChange = (e) => {
        const newTimeframe = e.target.value;
        const newParams = config.macdParamsByTimeframe[newTimeframe][0];
        onChange({ ...value, timeframe: newTimeframe, params: newParams });
    };
    const currentParams = config.macdParamsByTimeframe[value.timeframe] || [];
    const baseInputStyle = "w-full p-2 bg-[var(--bg-dark-primary)] border border-[var(--border-color)] rounded-md focus:ring-2 focus:ring-[var(--accent-primary)]";
    return (
        <div className="flex flex-col space-y-3 p-3 border border-[var(--border-color)] rounded-lg bg-[var(--bg-dark-primary)]">
            <select value={value.type} onChange={handleTypeChange} className={`${baseInputStyle} font-semibold`}>
                <option value="indicator">Indicator</option>
                <option value="literal">Number</option>
            </select>
            {isIndicator ? (
                <>
                    <select value={value.timeframe} onChange={handleTimeframeChange} className={baseInputStyle}>{config.timeframes.map(tf => <option key={tf} value={tf}>{tf}</option>)}</select>
                    <select value={value.params.join(',')} onChange={e => onChange({ ...value, params: e.target.value.split(',').map(Number) })} className={baseInputStyle}>{currentParams.map(p => <option key={p.join(',')} value={p.join(',')}>{p.join(',')}</option>)}</select>
                    <select value={value.value} onChange={e => onChange({ ...value, value: e.target.value })} className={baseInputStyle}>{config.macdValues.map(v => <option key={v} value={v}>{v}</option>)}</select>
                    <select value={value.offset} onChange={e => onChange({ ...value, offset: parseInt(e.target.value, 10) })} className={baseInputStyle}>
                        <option value={0}>Current Candle</option><option value={-1}>Previous Candle (PAST1)</option><option value={-2}>2 Candles Ago (PAST2)</option>
                    </select>
                </>
            ) : (
                <input type="number" step="any" value={value.value} onChange={e => onChange({ ...value, value: parseFloat(e.target.value) || 0 })} className={baseInputStyle} placeholder="Enter a number" />
            )}
        </div>
    );
};

const Toast = ({ message, show }) => {
    if (!show) return null;
    return (
        <div className="fixed bottom-5 right-5 bg-green-600 text-white py-2 px-4 rounded-lg shadow-lg animate-bounce">
            {message}
        </div>
    );
};

// --- Main Component ---
function RuleBuilder() {
    const [rules, setRules] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [appConfig, setAppConfig] = useState(null);
    const [isFormVisible, setIsFormVisible] = useState(false);

    const [isSaving, setIsSaving] = useState(false);
    const [toastMessage, setToastMessage] = useState('');
    const [deletingId, setDeletingId] = useState(null);

    const [ruleName, setRuleName] = useState('');
    const [signal, setSignal] = useState('');
    const [conditions, setConditions] = useState([]);
    const [editingRuleId, setEditingRuleId] = useState(null);

    const showToast = (message) => {
        setToastMessage(message);
        setTimeout(() => setToastMessage(''), 3000);
    };

    const resetForm = useCallback((config) => {
        const targetConfig = config || appConfig;
        setRuleName('');
        setSignal('');
        setEditingRuleId(null);
        if (targetConfig) {
            const defaultTimeframe = targetConfig.timeframes[0];
            const defaultParams = targetConfig.macdParamsByTimeframe[defaultTimeframe][0];
            const defaultIndicator = { type: 'indicator', source: 'macd', timeframe: defaultTimeframe, params: defaultParams, value: 'macd_line', offset: 0 };
            setConditions([{ operand1: { ...defaultIndicator }, operator: targetConfig.operators[0], operand2: { ...defaultIndicator, value: 'signal_line' } }]);
        }
    }, [appConfig]);

    const handleAddNewClick = () => {
        resetForm(appConfig);
        setIsFormVisible(true);
    };

    const handleEditClick = (rule) => {
        setEditingRuleId(rule.id);
        setRuleName(rule.name);
        setSignal(rule.signal);
        setConditions(rule.conditions);
        setIsFormVisible(true);
        window.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top to see form on mobile
    };

    const handleCancel = () => {
        resetForm(appConfig);
        setIsFormVisible(false);
    };

    useEffect(() => {
        const fetchInitialData = async () => {
            setIsLoading(true);
            try {
                const [configRes, rulesRes] = await Promise.all([getConfig(), getRules()]);
                setAppConfig(configRes.data);
                setRules(rulesRes.data);
                resetForm(configRes.data);
            } catch (error) {
                console.error("Failed to fetch initial data:", error);
            } finally {
                setIsLoading(false);
            }
        };
        fetchInitialData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const fetchRules = async () => {
        try {
            const response = await getRules();
            setRules(response.data);
        } catch (error) { console.error("Failed to fetch rules:", error); }
    };

    const handleTelegramToggle = async (ruleToUpdate) => {
        const updatedRule = { ...ruleToUpdate, telegram_enabled: !ruleToUpdate.telegram_enabled };
        setRules(currentRules => currentRules.map(r => r.id === updatedRule.id ? updatedRule : r));
        try {
            await updateRule(ruleToUpdate.id, updatedRule);
        } catch (error) {
            console.error("Failed to update Telegram toggle:", error);
            setRules(currentRules => currentRules.map(r => r.id === ruleToUpdate.id ? ruleToUpdate : r));
        }
    };

    const handleConditionChange = (index, part, newValue) => setConditions(conditions.map((c, i) => i === index ? { ...c, [part]: newValue } : c));
    const addCondition = () => {
        const defaultTimeframe = appConfig.timeframes[0];
        const defaultParams = appConfig.macdParamsByTimeframe[defaultTimeframe][0];
        const defaultIndicator = { type: 'indicator', source: 'macd', timeframe: defaultTimeframe, params: defaultParams, value: 'macd_line', offset: 0 };
        setConditions([...conditions, { operand1: defaultIndicator, operator: appConfig.operators[0], operand2: defaultLiteral }]);
    };
    const removeCondition = (index) => setConditions(conditions.filter((_, i) => i !== index));

    const handleDelete = async (ruleId) => {
        if (window.confirm("Are you sure you want to permanently delete this rule?")) {
            setDeletingId(ruleId);
            try {
                await deleteRule(ruleId);
                showToast('Logic deleted successfully!');
                await fetchRules();
            } catch (error) {
                console.error("Failed to delete rule:", error);
                alert("Could not delete rule. Please try again.");
            } finally {
                setDeletingId(null);
            }
        }
    };

    const handleSaveOrUpdateRule = async (e) => {
        e.preventDefault();
        setIsSaving(true);
        const ruleJSON = {
            name: ruleName,
            signal: signal,
            conditions: conditions,
            telegram_enabled: rules.find(r => r.id === editingRuleId)?.telegram_enabled || false
        };
        try {
            if (editingRuleId) {
                await updateRule(editingRuleId, ruleJSON);
                showToast('Logic updated successfully!');
            } else {
                await saveRule(ruleJSON);
                showToast('New logic saved successfully!');
            }
            await fetchRules();
            setIsFormVisible(false);
        } catch (error) {
            console.error("Failed to save/update rule:", error);
            alert("Failed to save rule. Check console for errors.");
        } finally {
            setIsSaving(false);
        }
    };

    if (isLoading || !appConfig) {
        return <div className="container mx-auto p-4 text-center text-[var(--text-secondary)]">Loading Logic Engine...</div>;
    }

    return (
        <div className="container mx-auto p-4 md:p-6">
            <Toast message={toastMessage} show={!!toastMessage} />
            <div className="flex justify-between items-center mb-8">
                {/* âœ… CHANGED: Responsive text size */}
                <h1 className="text-3xl md:text-4xl font-extrabold text-white">Logic Engine</h1>
                {/* IMPROVEMENT: Hide "Create New Logic" button when form is visible */}
                {!isFormVisible && (
                    <button onClick={handleAddNewClick} className="bg-[var(--accent-primary)] hover:bg-[var(--accent-primary-hover)] text-white font-bold py-2 px-4 rounded-lg shadow-lg transition-colors whitespace-nowrap">
                        + Create New Logic
                    </button>
                )}
            </div>

            {isFormVisible && (
                <div className="bg-[var(--bg-dark-secondary)] border border-[var(--border-color)] rounded-xl p-6 mb-8 shadow-2xl">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-2xl font-bold">{editingRuleId ? 'Edit Logic' : 'Create New Logic'}</h2>
                        <button onClick={handleCancel} className="text-[var(--text-secondary)] hover:text-white"><CloseIcon /></button>
                    </div>

                    <form onSubmit={handleSaveOrUpdateRule}>
                        {/* IMPROVEMENT: Ensure input fields stack nicely on mobile */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                            <input type="text" placeholder="Rule Name (e.g., L33BC Rule)" value={ruleName} onChange={e => setRuleName(e.target.value)} required className="p-3 bg-[var(--bg-dark-primary)] border border-[var(--border-color)] rounded-md focus:ring-2 focus:ring-[var(--accent-primary)]" />
                            <input type="text" placeholder="Signal on Trigger (e.g., L33BC_BUY)" value={signal} onChange={e => setSignal(e.target.value)} required className="p-3 bg-[var(--bg-dark-primary)] border border-[var(--border-color)] rounded-md focus:ring-2 focus:ring-[var(--accent-primary)]" />
                        </div>
                        <h3 className="text-lg font-semibold mb-2 text-gray-300">Conditions (All must be TRUE)</h3>
                        <div className="space-y-4">{conditions.map((cond, index) => (
                            // âœ… CHANGED: From a complex grid to a responsive flex layout
                            // IMPROVEMENT: Ensure operands and operator stack on mobile, then go horizontal on larger screens
                            <div key={index} className="flex flex-col lg:flex-row gap-4 items-stretch lg:items-center bg-[var(--bg-dark-secondary)] p-4 rounded-lg border border-[var(--border-color)]">
                                <AdvancedOperandSelector value={cond.operand1} onChange={(val) => handleConditionChange(index, 'operand1', val)} config={appConfig} />
                                {/* IMPROVEMENT: Operator takes full width on mobile, then auto-width on larger screens */}
                                <select value={cond.operator} onChange={(e) => handleConditionChange(index, 'operator', e.target.value)} className="w-full lg:w-auto p-3 bg-[var(--bg-dark-primary)] border border-[var(--border-color)] rounded-md focus:ring-2 focus:ring-[var(--accent-primary)] font-mono text-lg text-center">
                                    {appConfig.operators.map(op => <option key={op} value={op}>{op}</option>)}
                                </select>
                                <AdvancedOperandSelector value={cond.operand2} onChange={(val) => handleConditionChange(index, 'operand2', val)} config={appConfig} />
                                <button type="button" onClick={() => removeCondition(index)} className="bg-red-600/20 text-red-400 p-2 rounded-full hover:bg-red-500 hover:text-white transition-colors self-center flex-shrink-0"><CloseIcon /></button>
                            </div>
                        ))}</div>
                        <button type="button" onClick={addCondition} className="mt-4 text-sm text-[var(--accent-primary)] hover:underline">+ Add Condition</button>
                        {/* IMPROVEMENT: Buttons stack on mobile, then go side-by-side on small screens+ */}
                        <div className="flex flex-col sm:flex-row items-stretch gap-4 mt-6 border-t border-[var(--border-color)] pt-6">
                            <button type="submit" disabled={isSaving} className="flex-grow bg-[var(--accent-primary)] hover:bg-[var(--accent-primary-hover)] text-white font-bold py-3 px-4 rounded-lg shadow-lg transition-colors flex items-center justify-center disabled:opacity-50">
                                {isSaving ? <><Spinner /><span>Saving...</span></> : (editingRuleId ? 'Update Rule' : 'Save New Rule')}
                            </button>
                            <button type="button" onClick={handleCancel} className="flex-grow bg-[var(--bg-dark-secondary)] border border-[var(--border-color)] hover:bg-[var(--border-color)] text-[var(--text-secondary)] hover:text-white font-bold py-3 px-4 rounded-lg transition-colors">Cancel</button>
                        </div>
                    </form>
                </div>
            )}

            <div className="bg-[var(--bg-dark-secondary)] border border-[var(--border-color)] rounded-xl shadow-lg">
                <h3 className="text-xl font-bold p-4 border-b border-[var(--border-color)]">Saved Logic Library</h3>
                {rules.length === 0 ? <p className="p-4 text-[var(--text-secondary)]">No logic saved yet. Click 'Create New Logic' to begin.</p> :
                    <ul>{rules.map(rule => (
                        // âœ… CHANGED: Main list item now stacks vertically on mobile
                        <li key={rule.id} className={`border-b border-[var(--border-color)] p-4 flex flex-col sm:flex-row sm:justify-between sm:items-center hover:bg-[var(--bg-dark-primary)] transition-colors ${deletingId === rule.id ? 'opacity-50' : ''}`}>
                            {/* IMPROVEMENT: Ensure rule name and signal stack on mobile */}
                            <div className="mb-2 sm:mb-0 flex flex-col items-start sm:flex-row sm:items-baseline sm:gap-2">
                                <span className="font-bold text-lg text-white break-words">{rule.name}</span>
                                <span className="text-sm font-mono bg-gray-700/50 text-gray-300 px-2 py-1 rounded whitespace-nowrap block sm:inline-block">{rule.signal}</span>
                            </div>
                            {/* IMPROVEMENT: Telegram toggle and action buttons stack on mobile */}
                            <div className="flex flex-col items-start gap-2 sm:flex-row sm:items-center sm:gap-4 mt-4 sm:mt-0">
                                <label htmlFor={`telegram-${rule.id}`} className="flex items-center justify-between cursor-pointer w-full sm:w-auto">
                                    <span className="mr-3 text-sm text-[var(--text-secondary)] whitespace-nowrap">Telegram Alert</span>
                                    <div className="relative">
                                        <input type="checkbox" id={`telegram-${rule.id}`} className="sr-only" checked={!!rule.telegram_enabled} onChange={() => handleTelegramToggle(rule)} disabled={deletingId === rule.id}/>
                                        <div className="block bg-gray-600 w-10 h-6 rounded-full"></div>
                                        <div className="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full"></div>
                                    </div>
                                </label>
                                <button onClick={() => handleEditClick(rule)} className="text-blue-400 hover:text-blue-300 font-semibold disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap w-full sm:w-auto">Edit</button>
                                <button onClick={() => handleDelete(rule.id)} className="text-red-500 hover:text-red-400 font-semibold disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap w-full sm:w-auto">
                                    {deletingId === rule.id ? 'Deleting...' : 'Delete'}
                                </button>
                            </div>
                        </li>
                    ))}</ul>
                }
            </div>
        </div>
    );
}

export default RuleBuilder;

