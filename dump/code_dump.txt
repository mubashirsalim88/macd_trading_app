
================================================================================
# ðŸ“„ run.py
================================================================================

# run.py

from apscheduler.schedulers.blocking import BlockingScheduler
from src.engine import main

def job():
    print("[SCHEDULER] Running scheduled MACD job...\n")
    main()

if __name__ == "__main__":
    scheduler = BlockingScheduler()
    scheduler.add_job(job, 'interval', minutes=1)
    print("[INIT] Starting scheduler to run MACD engine every minute...")
    scheduler.start()



================================================================================
# ðŸ“„ api\app.py
================================================================================

# api/app.py

from flask import Flask, jsonify, request
from flask_cors import CORS
from src.redis_client import r
from api.logic_evaluator import evaluate_all_tickers
import json
import os
from dotenv import load_dotenv
from typing import List, Optional

# Load API key from environment
load_dotenv()
API_KEY = os.getenv("API_KEY")

app = Flask(__name__)
CORS(app)

def require_api_key():
    client_key = request.headers.get('X-API-KEY')
    if client_key != API_KEY:
        return jsonify({"error": "Unauthorized"}), 401
    return None

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({"status": "ok", "message": "API is running"})

@app.route('/api/data/<string:ticker>', methods=['GET'])
def get_data(ticker: str):
    auth_error = require_api_key()
    if auth_error:
        return auth_error

    try:
        keys = r.keys(f"{ticker}:*")  # type: ignore
        keys: List[bytes] = keys
        
        if not keys:
            return jsonify({"error": f"No data found for ticker {ticker}"}), 404
        
        result = {ticker: {}}
        for key in keys:
            key_str = key.decode('utf-8')
            _, interval, params = key_str.split(':')
            data = r.get(key)  # type: ignore
            data: Optional[bytes] = data
            if data:
                data_list = json.loads(data.decode('utf-8'))
                if isinstance(data_list, list) and len(data_list) == 3:
                    result[ticker][f"{interval}:{params}"] = [
                        {
                            "macd_line": item["macd_line"],
                            "signal_line": item["signal_line"],
                            "histogram": item["histogram"],
                            "date": item["date"]
                        }
                        for item in data_list
                    ]
        
        if not result[ticker]:
            return jsonify({"error": f"No valid data found for ticker {ticker}"}), 404
            
        return jsonify(result)
    
    except Exception as e:
        return jsonify({"error": f"Failed to fetch data for {ticker}: {str(e)}"}), 500

@app.route('/api/signals', methods=['GET'])
def get_signals():
    auth_error = require_api_key()
    if auth_error:
        return auth_error
    try:
        signals = evaluate_all_tickers()
        return jsonify(signals), 200
    except Exception as e:
        return jsonify({"error": f"Failed to evaluate signals: {str(e)}"}), 500

if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=5000)



================================================================================
# ðŸ“„ api\logic_evaluator.py
================================================================================

from src.redis_client import get_macd_from_redis
from src.config import CRYPTO_TICKERS
from typing import Dict, Optional, List

def jgd_L33bc(ticker: str) -> str:
    """
    Evaluates the 'L33BC' trading logic for a given ticker using 1m interval data.
    Returns 'L33BC(BUY)', 'L33BC(SELL)', or 'NO_SIGNAL'.
    """
    try:
        # Define the parameters needed for this specific logic
        params_36_78_27 = {'fast': 36, 'slow': 78, 'signal': 27}
        params_60_130_45 = {'fast': 60, 'slow': 130, 'signal': 45}
        params_180_390_135 = {'fast': 180, 'slow': 390, 'signal': 135}
        params_360_780_270 = {'fast': 360, 'slow': 780, 'signal': 270}
        params_720_1560_540 = {'fast': 720, 'slow': 1560, 'signal': 540}

        # Fetch the required data from Redis (list of 3 candles)
        data_36 = get_macd_from_redis(ticker, '1m', params_36_78_27)
        data_60 = get_macd_from_redis(ticker, '1m', params_60_130_45)
        data_180 = get_macd_from_redis(ticker, '1m', params_180_390_135)
        data_360 = get_macd_from_redis(ticker, '1m', params_360_780_270)
        data_720 = get_macd_from_redis(ticker, '1m', params_720_1560_540)
        
        # If any data is missing or not a list of 3 candles, return NO_SIGNAL
        if not all([data_36, data_60, data_180, data_360, data_720]) or \
           not all(isinstance(d, list) and len(d) == 3 for d in [data_36, data_60, data_180, data_360, data_720]):
            return "NO_SIGNAL"

        # Assign CUR, PAST1, PAST2 values from the list of 3 candles
        # Candle -1 is CUR, -2 is PAST1, -3 is PAST2
        # Use type: ignore to suppress Pylance warnings, as checks above ensure data is valid
        fl_36_cur = data_36[-1]['macd_line']  # type: ignore
        fl_36_past1 = data_36[-2]['macd_line']  # type: ignore
        fl_36_past2 = data_36[-3]['macd_line']  # type: ignore
        sl_36_cur = data_36[-1]['signal_line']  # type: ignore
        sl_36_past1 = data_36[-2]['signal_line']  # type: ignore
        sl_36_past2 = data_36[-3]['signal_line']  # type: ignore

        fl_60_cur = data_60[-1]['macd_line']  # type: ignore
        fl_60_past1 = data_60[-2]['macd_line']  # type: ignore
        fl_60_past2 = data_60[-3]['macd_line']  # type: ignore
        sl_60_cur = data_60[-1]['signal_line']  # type: ignore

        fl_180_cur = data_180[-1]['macd_line']  # type: ignore
        fl_180_past1 = data_180[-2]['macd_line']  # type: ignore
        fl_180_past2 = data_180[-3]['macd_line']  # type: ignore
        sl_180_cur = data_180[-1]['signal_line']  # type: ignore
        sl_180_past1 = data_180[-2]['signal_line']  # type: ignore
        sl_180_past2 = data_180[-3]['signal_line']  # type: ignore
        
        fl_360_cur = data_360[-1]['macd_line']  # type: ignore
        fl_360_past1 = data_360[-2]['macd_line']  # type: ignore
        fl_360_past2 = data_360[-3]['macd_line']  # type: ignore
        
        fl_720_cur = data_720[-1]['macd_line']  # type: ignore
        fl_720_past1 = data_720[-2]['macd_line']  # type: ignore
        fl_720_past2 = data_720[-3]['macd_line']  # type: ignore

        # --- Logic Conditions ---
        # Condition set 1: Based on MACD(36,78,27)
        cond1 = (fl_36_cur > fl_36_past1 > fl_36_past2 and
                 sl_36_cur > sl_36_past1 > sl_36_past2 and
                 fl_36_cur < 0 and
                 sl_36_cur < 0 and
                 fl_36_cur > sl_36_cur)
        
        # Condition set 2 (#3BC): Based on MACD(60,130,45)
        cond2 = (fl_36_cur != 0 and fl_60_cur / abs(fl_36_cur) >= 3 and
                 fl_60_cur < sl_60_cur and
                 fl_60_cur > fl_60_past1 > fl_60_past2)

        # Condition set 3 (#4DOM): Based on MACD(180,390,135)
        cond3 = (fl_180_cur > fl_180_past1 > fl_180_past2 and
                 sl_180_cur > sl_180_past1 > sl_180_past2)

        # Condition set 4 (#SUPP): Supportive conditions
        cond4 = (fl_360_cur > fl_360_past1 > fl_360_past2 and
                 fl_720_cur > fl_720_past1 > fl_720_past2)

        # Return BUY if all conditions are met, else NO_SIGNAL
        # Note: SELL signal not implemented as per provided logic
        if all([cond1, cond2, cond3, cond4]):
            return "L33BC(BUY)"
        return "NO_SIGNAL"

    except (KeyError, IndexError, TypeError, ZeroDivisionError) as e:
        print(f"[LOGIC ERROR] Could not evaluate 'jgd_L33bc' for {ticker}: {e}")
        return "NO_SIGNAL"

def evaluate_all_tickers() -> Dict[str, str]:
    """
    Runs jgd_L33bc for all tickers using 1m interval.
    Returns a dictionary of ticker:signal pairs.
    """
    results = {}
    for ticker in CRYPTO_TICKERS:
        signal = jgd_L33bc(ticker)
        results[ticker] = signal
    return results

if __name__ == "__main__":
    signals = evaluate_all_tickers()
    print(signals)


================================================================================
# ðŸ“„ src\config.py
================================================================================

# config.py

CRYPTO_TICKERS = [
    "BTC-USD", "ETH-USD", "BNB-USD", "SOL-USD", "XRP-USD", "DOGE-USD",
    "ADA-USD", "AVAX-USD", "SHIB-USD", "DOT-USD", "LINK-USD", "MATIC-USD",
    "TRX-USD", "LTC-USD", "BCH-USD", "ICP-USD", "ATOM-USD", "XLM-USD",
    "ETC-USD", "FIL-USD", "HBAR-USD", "APT-USD", "IMX-USD", "ARB-USD",
    "CRO-USD", "NEAR-USD", "QNT-USD", "OP-USD", "VET-USD", "RUNE-USD",
    "AAVE-USD", "GRT-USD", "EGLD-USD", "MKR-USD", "ALGO-USD", "XTZ-USD",
    "SAND-USD", "THETA-USD", "AXS-USD", "CHZ-USD", "ZEC-USD", "LDO-USD",
    "FTM-USD"
]

MACD_PARAMS = {
    '1m': [
        (12, 26, 9),
        (36, 78, 27),
        (60, 130, 45),
        (180, 390, 135),
        (360, 780, 270),
        (720, 1560, 540),
        (2160, 4680, 1620)
    ],
    '5m': [
        (12, 26, 9),
        (36, 78, 27),
        (72, 156, 54),
        (144, 312, 108),
        (432, 936, 324),
        (900, 1950, 675),
        (4500, 9750, 3375)
    ],
    '15m': [
        (12, 26, 9),
        (24, 52, 18),
        (48, 104, 36),
        (144, 312, 108),
        (300, 650, 225),
        (1500, 3250, 1125),
        (3000, 6500, 2250)
    ]
}



================================================================================
# ðŸ“„ src\data_fetcher.py
================================================================================

import yfinance as yf
import pandas as pd

def get_historical_data(ticker, period='6mo', interval='1d'):
    try:
        df = yf.download(ticker, period=period, interval=interval, auto_adjust=False)
        if df is None or df.empty:
            print(f"[Warning] No data returned for {ticker}.")
            return pd.DataFrame()
        return df
    except Exception as e:
        print(f"[Error] Failed to fetch data for {ticker}: {e}")
        return pd.DataFrame()



================================================================================
# ðŸ“„ src\engine.py
================================================================================

from src.data_fetcher import get_historical_data
from src.indicator_calculator import add_macd
from src.config import CRYPTO_TICKERS, MACD_PARAMS
from src.redis_client import save_macd_to_redis
import pandas as pd

def main():
    print("[INFO] Starting full scan of all tickers and MACD parameter sets...\n")

    for ticker in CRYPTO_TICKERS:
        for interval, param_list in MACD_PARAMS.items():
            print(f"--- {ticker} @ {interval} ---")

            df = get_historical_data(ticker, period="7d", interval=interval)
            if df.empty:
                print(f"[WARNING] No data for {ticker} ({interval}) â€” skipping.")
                continue

            for params in param_list:
                fast, slow, signal = params

                df_macd = add_macd(df.copy(), fast=fast, slow=slow, signal=signal)
                if df_macd.empty:
                    continue

                # Get the last 3 rows of the DataFrame
                last_three_rows = df_macd.tail(3)
                if len(last_three_rows) < 3:
                    print(f"[WARNING] Not enough data for {ticker} {params} (found {len(last_three_rows)} rows), skipping.")
                    continue

                # Convert the last 3 rows to a list of dictionaries
                data_to_save = [
                    {
                        "macd_line": float(row.macd_line.iloc[0]),
                        "signal_line": float(row.signal_line.iloc[0]),
                        "histogram": float(row.histogram.iloc[0]),
                        "date": str(index.date())
                    }
                    for index, row in last_three_rows.iterrows()
                ]

                save_macd_to_redis(
                    ticker,
                    interval,
                    {"fast": fast, "slow": slow, "signal": signal},
                    data_to_save
                )

    print("\nâœ… [INFO] Full scan complete.\n")

if __name__ == "__main__":
    main()



================================================================================
# ðŸ“„ src\indicator_calculator.py
================================================================================

# indicator_calculator.py

import pandas as pd

def add_macd(df, fast=12, slow=26, signal=9):
    if 'Close' not in df.columns:
        print("[Error] 'Close' column not found in DataFrame.")
        return df

    # Calculate EMAs
    df['fast_ema'] = df['Close'].ewm(span=fast, adjust=False).mean()
    df['slow_ema'] = df['Close'].ewm(span=slow, adjust=False).mean()

    # MACD and Signal
    df['macd_line'] = df['fast_ema'] - df['slow_ema']
    df['signal_line'] = df['macd_line'].ewm(span=signal, adjust=False).mean()

    # Histogram
    df['histogram'] = df['macd_line'] - df['signal_line']

    return df



================================================================================
# ðŸ“„ src\redis_client.py
================================================================================

# src/redis_client.py

import redis
from redis import Redis
from typing import Optional, cast, Union, List
import os
import json

REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
REDIS_PORT = int(os.getenv("REDIS_PORT", 6379))
REDIS_DB = int(os.getenv("REDIS_DB", 0))

r: Redis = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=REDIS_DB)

def save_macd_to_redis(ticker: str, interval: str, params: dict, data: Union[dict, List[dict]]) -> None:
    key = f"{ticker}:{interval}:{params['fast']}-{params['slow']}-{params['signal']}"
    try:
        r.set(key, json.dumps(data))
        print(f"[REDIS] Saved MACD for {key}")
    except Exception as e:
        print(f"[REDIS ERROR] Failed to save {key}: {e}")

def get_macd_from_redis(ticker: str, interval: str, params: dict) -> Optional[List[dict]]:
    key = f"{ticker}:{interval}:{params['fast']}-{params['slow']}-{params['signal']}"
    try:
        val = r.get(key)
        if val:
            val = cast(bytes, val)
            return json.loads(val.decode("utf-8"))
        return None
    except Exception as e:
        print(f"[REDIS ERROR] Failed to fetch {key}: {e}")
        return None

